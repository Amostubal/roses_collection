
biomeTokens = { 
                ANY_LAND = 'Any Land',
                ALL_MAIN = 'All Main',
                ANY_OCEAN = 'Any Ocean',
                ANY_LAKE = 'Any Lake',
                ANY_TEMPERATE_LAKE = 'Temperate Lakes',
                ANY_TROPICAL_LAKE = 'Tropical Lakes',
                ANY_RIVER = 'Lives in any rivers',
                ANY_TEMPERATE_RIVER = 'Temperate Rivers',
                ANY_TROPICAL_RIVER = 'Tropical Rivers',
                ANY_POOL = 'Any Pool',
                NOT_FREEZING = 'Not Freezing',
                ANY_TEMPERATE = 'Any Temperate',
                ANY_TROPICAL = 'Any Tropical',
                ANY_FOREST = 'Any Forest',
                ANY_SHRUBLAND = 'Any Shrubland',
                ANY_GRASSLAND = 'Any Grassland',
                ANY_SAVANNA = 'Any Savanna',
                ANY_TEMPERATE_FOREST = 'Any Temperate Forest',
                ANY_TROPICAL_FOREST = 'Any Tropical Forest',
                ANY_TEMPERATE_BROADLEAF = 'Any Temperate Vegetation',
                ANY_TROPICAL_BROADLEAF = 'Any Tropical Vegetation',
                ANY_WETLAND = 'Any Wetland',
                ANY_TEMPERATE_WETLAND = 'Any Temperate Wetland',
                ANY_TROPICAL_WETLAND = 'Any Tropical Wetland',
                ANY_TEMPERATE_MARSH = 'Any Temperate Marsh',
                ANY_TROPICAL_MARSH = 'Any Tropical Marsh',
                ANY_TEMPERATE_SWAMP = 'Any Temperate Swamp',
                ANY_TROPICAL_SWAMP = 'Any Tropical Swamp',
                ANY_DESERT = 'Any Desert',
                MOUNTAIN = 'Mountains',
                MOUNTAINS = 'Mountains',
                GLACIER = 'Glaciers',
                TUNDRA = 'Tundra',
                SWAMP_TEMPERATE_FRESHWATER = 'Temperate Freshwater Swamp',
                SWAMP_TEMPERATE_SALTWATER = 'Temperate Saltwater Swamp',
                SWAMP_TROPICAL_FRESHWATER = 'Tropical Freshwater Swamp',
                SWAMP_TROPICAL_SALTWATER = 'Tropical Saltwater Swamp',
                SWAMP_MANGROVE = 'Mangrove Swamp',
                MARSH_TEMPERATE_FRESHWATER = 'Temperate Freshwater Marsh',
                MARSH_TEMPERATE_SALTWATER = 'Temperate Saltwater Marsh',
                MARSH_TROPICAL_FRESHWATER = 'Tropical Freshwater Marsh',
                MARSH_TROPICAL_SALTWATER = 'Tropical Saltwater Marsh',
                FOREST_TAIGA = 'Taiga',
                TAIGA = 'Taiga',
                FOREST_TEMPERATE_BROADLEAF = 'Temperate Broadleaf Forest',
                FOREST_TEMPERATE_CONIFER = 'Temperate Conifer Forest',
                FOREST_TROPICAL_DRY_BROADLEAF = 'Tropical Dry Broadleaf Forest',
                FOREST_TROPICAL_MOIST_BROADLEAF = 'Tropical Moist Broadleaf Forest',
                FOREST_TROPICAL_CONIFER = 'Tropical Conifer Forest',
                GRASSLAND_TEMPERATE = 'Temperate Grassland',
                GRASSLAND_TROPICAL = 'Tropical Grassland',
                SHRUBLAND_TEMPERATE = 'Temperate Shrubland',
                SHRUBLAND_TROPICAL = 'Tropical Shrubland',
                SAVANNA_TEMPERATE = 'Temperate Savanna',
                SAVANNA_TROPICAL = 'Tropical Savanna',
                OCEAN_ARCTIC = 'Arctic Ocean',
                OCEAN_TEMPERATE = 'Temperate Ocean',
                OCEAN_TROPICAL = 'Tropical Ocean',
                DESERT_BADLAND = 'Badlands',
                DESERT_ROCK = 'Rocky Wastes',
                DESERT_SAND = 'Sandy Desert',
                POOL_TEMPERATE_FRESHWATER = 'Temperate Freshwater Pool',
                POOL_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater Pool',
                POOL_TEMPERATE_SALTWATER = 'Temperate Saltwater Pool',
                POOL_TROPICAL_FRESHWATER = 'Tropical Freshwater Pool',
                POOL_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater Pool',
                POOL_TROPICAL_SALTWATER = 'Tropical Saltwater Pool',
                LAKE_TEMPERATE_FRESHWATER = 'Temperate Freshwater Lake',
                LAKE_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater Lake',
                LAKE_TEMPERATE_SALTWATER = 'Temperate Saltwater Lake',
                LAKE_TROPICAL_FRESHWATER = 'Tropical Freshwater Lake',
                LAKE_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater Lake',
                LAKE_TROPICAL_SALTWATER = 'Tropical Saltwater Lake',
                RIVER_TEMPERATE_FRESHWATER = 'Temperate Freshwater River',
                RIVER_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater River',
                RIVER_TEMPERATE_SALTWATER = 'Temperate Saltwater River',
                RIVER_TROPICAL_FRESHWATER = 'Tropical Freshwater River',
                RIVER_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater River',
                RIVER_TROPICAL_SALTWATER = 'Tropical Saltwater River',
                SUBTERRANEAN_WATER = 'Subterranean Water',
                SUBTERRANEAN_CHASM = 'Subterranean Chasm',
                SUBTERRANEAN_LAVA = 'Subterranean Lava',
                BIOME_MOUNTAIN = 'Mountain',
                BIOME_GLACIER = 'Glacier',
                BIOME_TUNDRA = 'Tundra',
                BIOME_SWAMP_TEMPERATE_FRESHWATER = 'Temperate Freshwater Swamp',
                BIOME_SWAMP_TEMPERATE_SALTWATER = 'Temperate Saltwater Swamp',
                BIOME_MARSH_TEMPERATE_FRESHWATER = 'Temperate Freshwater Marsh',
                BIOME_MARSH_TEMPERATE_SALTWATER = 'Temperate Saltwater Marsh',
                BIOME_SWAMP_TROPICAL_FRESHWATER = 'Tropical Freshwater Swamp',
                BIOME_SWAMP_TROPICAL_SALTWATER = 'Tropical Saltwater Swamp',
                BIOME_SWAMP_MANGROVE = 'Mangrove Swamp',
                BIOME_MARSH_TROPICAL_FRESHWATER = 'Tropical Freshwater Marsh',
                BIOME_MARSH_TROPICAL_SALTWATER = 'Tropical Saltwater Marsh',
                BIOME_FOREST_TAIGA = 'Taiga',
                BIOME_FOREST_TEMPERATE_CONIFER = 'Temperate Coniferous Forest',
                BIOME_FOREST_TEMPERATE_BROADLEAF = 'Temperate Broadlead Forest',
                BIOME_FOREST_TROPICAL_CONIFER = 'Tropical Coniferous Forest',
                BIOME_FOREST_TROPICAL_DRY_BROADLEAF = 'Tropical Dry Broadleaf Forest',
                BIOME_FOREST_TROPICAL_MOIST_BROADLEAF = 'Tropical Moist Broadleaf Forest',
                BIOME_GRASSLAND_TEMPERATE = 'Temperate Grassland',
                BIOME_SAVANNA_TEMPERATE = 'Temperate Savanna',
                BIOME_SHRUBLAND_TEMPERATE = 'Temperate Shrubland',
                BIOME_GRASSLAND_TROPICAL = 'Tropical Grassland',
                BIOME_SAVANNA_TROPICAL = 'Tropical Savanna',
                BIOME_SHRUBLAND_TROPICAL = 'Tropical Shrubland',
                BIOME_DESERT_BADLAND = 'Badland Desert',
                BIOME_DESERT_ROCK = 'Rock Desert',
                BIOME_DESERT_SAND = 'Sand Desert',
                BIOME_OCEAN_TROPICAL = 'Tropical Ocean',
                BIOME_OCEAN_TEMPERATE = 'Temperate Ocean',
                BIOME_OCEAN_ARCTIC = 'Arctic Ocean',
                BIOME_SUBTERRANEAN_WATER = 'Underground Water',
                BIOME_SUBTERRANEAN_CHASM = 'Ungerground Chasm',
                BIOME_SUBTERRANEAN_LAVA = 'Underground Lava',
                BIOME_POOL_TEMPERATE_FRESHWATER = 'Temperate Freshwater Pool',
                BIOME_POOL_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater Pool',
                BIOME_POOL_TEMPERATE_SALTWATER = 'Temperate Saltwater Pool',
                BIOME_POOL_TROPICAL_FRESHWATER = 'Tropical Freshwater Pool',
                BIOME_POOL_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater Pool',
                BIOME_POOL_TROPICAL_SALTWATER = 'Tropical Saltwater Pool',
                BIOME_LAKE_TEMPERATE_FRESHWATER = 'Temperate Freshwater Lake',
                BIOME_LAKE_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater Lake',
                BIOME_LAKE_TEMPERATE_SALTWATER = 'Temperate Saltwater Lake',
                BIOME_LAKE_TROPICAL_FRESHWATER = 'Tropical Freshwater Lake',
                BIOME_LAKE_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater Lake',
                BIOME_LAKE_TROPICAL_SALTWATER = 'Tropical Saltwater Lake',
                BIOME_RIVER_TEMPERATE_FRESHWATER = 'Temperate Freshwater River',
                BIOME_RIVER_TEMPERATE_BRACKISHWATER = 'Temperate Brackishwater River',
                BIOME_RIVER_TEMPERATE_SALTWATER = 'Temperate Saltwater River',
                BIOME_RIVER_TROPICAL_FRESHWATER = 'Tropical Freshwater River',
                BIOME_RIVER_TROPICAL_BRACKISHWATER = 'Tropical Brackishwater River',
                BIOME_RIVER_TROPICAL_SALTWATER = 'Tropical Saltwater River'
              }
habitatFlags = {
AMPHIBIOUS = 'Amphibious',
AQUATIC = 'Aquatic',
GOOD = 'Living in good biomes',
EVIL = 'Living in evil biomes',
SAVAGE = 'Living in savage biomes'
              }
activeFlags = {
ALL_ACTIVE = 'At all times',
DIURNAL = 'During the day',
NOCTURNAL = 'During the night',
CREPUSCULAR = 'At dawn and dusk',
VESPERTINE = 'At dusk',
MATUTINAL = 'At dawn',
              }
utilityFlags = {
COMMON_DOMESTIC = 'Domesticated',
WAGON_PULLER = 'Can pull wagons',
PACK_ANIMAL = 'Can haul goods',
TRAINABLE_HUNTING = 'Can be trained to hunt',
TRAINABLE_WAR = 'Can be trained for fighting',
PET = 'Can be tamed',
PET_EXOTIC = 'Can be tamed with difficulty',
MOUNT = 'Can be used as a mount',
MOUNT_EXOTIC = 'Can be used as a mount',
               }               
dietFlags = {
NO_EAT = "Doesn't need food",
NO_DRINK = "Doesn't need drink",
BONECARN = 'Eats meat and bones',
CARNIVORE = 'Only eats meat',
GRAZER = 'Eats grass',
GOBBLE_VERMIN = 'Eats vermin',
            }
behaviorFlags = {
MISCHIEVOUS = 'Mischievous',
CURIOUSBEAST_ANY = 'Steals anything',
CURIOUSBEAST_ITEM = 'Steals items',
CURIOUSBEAST_GUZZLER = 'Steals drinks',
CURIOUSBEAST_EATER = 'Steals food',
TRAPAVOID = 'Avoids traps',
CAVE_ADAPT = 'Dislikes leaving caves',
HUNTS_VERMIN = 'Hunts vermin',
SOUND_ALERT = 'Creates sounds when alerted',
SOUND_PEACEFUL_INTERMITTENT = 'Creates sounds intermittently',
CRAZED = 'Constantly berserk',
FLEEQUICK = 'Quick to flee',
AT_PEACE_WITH_WILDLIFE = 'At peace with wildlife',
AMBUSHPREDATOR = 'Ambushes prey',
OPPOSED_TO_LIFE = 'Hostile to the living',
                }
movementFlags = {
FLIER = 'Can fly',
IMMOBILE = 'Can not move',
IMMOBILE_LAND = 'Can not move on land',
MEANDERER = 'Meanders around',
SWIMS_INNATE = 'Can swim',
CANNOT_JUMP = 'Can not jump',
STANCE_CLIMBER = 'can climb with its feet',
CANNOT_CLIMB = 'Can not climb',
SWIMS_LEARNED = 'Can learn to swim',
VERMIN_MICRO = 'Moves in a swarm',
UNDERSWIM = 'Swims underwater',
                }
immuneFlags = {
NO_DIZZINESS = 'Does not get dizzy',
NO_FEVERS = 'Does not get fevers',
NOEXERT = 'Does not get tired',
NOPAIN = 'Does not feel pain',
NOBREATHE = 'Does not breath',
NOSTUN = 'Can not be stunned',
PARALYZEIMMUNE = 'Can not be paralyzed',
NONAUSEA = 'Does not get nauseous',
NOEMOTION = 'Does not feel emotion',
NOFEAR = 'Can not be scared',
NO_SLEEP = "Doesn't need sleep",
FIREIMMUNE = 'Immune to fire',
FIREIMMUNE_SUPER = 'Immune to dragonfire',
WEBIMMUNE = 'Does not get caught in webs',
              }
bonusFlags = {
WEBBER = 'Creates webs',
THICKWEB = 'Webs large targets',
MAGMA_VISION = 'Can see in lava',
IMMOLATE = 'Radiates fire',
MULTIPART_FULL_VISION = 'Can see all around itself',
CAN_SPEAK = 'Can speak',
CAN_LEARN = 'Can learn',
CANOPENDOORS = 'Can open doors',
LOCKPICKER = 'Can pick locks',
EQUIPS = 'Can wear items',
LISP = 'Speaks with a lisp',
LIGHT_GEN = 'Generates light',
EXTRAVISION = 'Can see in the dark',
SLOW_LEARNER = 'Slow learner',
UTTERANCES = 'Unintelligible utterances',
             }              
bodyFlags = {
NOT_BUTCHERABLE = 'Can not be butchered',
COOKABLE_LIVE = 'Can be cooked live',
NOSKULL = 'Does not have a skull',
NOSKIN = 'Does not have skin',
NOBONES = 'Does not have bones',
NOMEAT = 'Does not have meat',
NOTHOUGHT = 'Does not have a brain',
NO_THOUGHT_CENTER_FOR_MOVEMENT = 'Does not need a brain to move',
VEGETATION = 'Made of swampstuff',
            }              
seasonFlags = {
NO_SPRING = 'Absent during the spring',
NO_SUMMER = 'Absent during the summer',
NO_AUTUMN = 'Absent during the fall',
NO_WINTER = 'Absent during the winter',
              }
seasonPlantFlags = {
SPRING = 'Grows during the spring',
SUMMER = 'Grows during the summer',
AUTUMN = 'Grows during the fall',
WINTER = 'Grows during the winter',
              }
typeCreatureFlags = {
                     FANCIFUL = 'Fanciful',
                     CASTE_MEGABEAST = 'Megabeast',
                     CASTE_SEMIMEGABEAST = 'Semi-Megabeast',
                     CASTE_BENIGN = 'Benign',
                     CASTE_POWER = 'Power',
                     CASTE_TITAN = 'Titan',
                     CASTE_FEATURE_BEAST = 'Feature Beast',
                     CASTE_UNIQUE_DEMON = 'Unique Demon',
                     CASTE_DEMON = 'Demon',
                     CASTE_NIGHT_CREATURE_ANY = 'Night Creature'
}
materialEdibleFlags = {
                        EDIBLE_VERMIN = 'Vermin',
                        EDIBLE_RAW = 'Raw',
                        EDIBLE_COOKED = 'Cooked'
}
materialItemFlags = {
                  ITEMS_WEAPON = 'Makes melee weapons',
                  ITEMS_WEAPON_RANGED = 'Makes ranges weapons',
                  ITEMS_ANVIL = 'Makes anvils',
                  ITEMS_AMMO = 'Makes ammo',
                  ITEMS_DIGGER = 'Makes digging items',
                  ITEMS_ARMOR = 'Makes armor',
                  ITEMS_DELICATE = 'Makes delicate items',
                  ITEMS_SIEGE_ENGINE = 'Makes siege engine ammo',
                  ITEMS_QUERN = 'Makes querns',
                  ITEMS_METAL = 'Makes metal items',
                  ITEMS_BARRED = 'Makes barred items',
                  ITEMS_SCALED = 'Makes scaled items',
                  ITEMS_LEATHER = 'Makes leather items',
                  ITEMS_SOFT = 'Makes soft items',
                  ITEMS_HARD = 'Makes hard items'
}
unusedFlags = {
--AMPHIBIOUS = 'Amphibious',
--AQUATIC = 'Aquatic',
--LARGE_PREDATOR = 'A predator',
--FISHITEM = 'Needs to be cleaned',
--MILKABLE = 'Milkable',
--BENIGN = 'Benign',
--VERMIN_NOROAM = false
--VERMIN_NOTRAP = true
--VERMIN_NOFISH = false
--HAS_NERVES = true
--NO_UNIT_TYPE_COLOR = false
--NO_CONNECTIONS_FOR_MOVEMENT = false
--SECRETION = 'Secrets substance',
--BLOOD = 'Has blood',
--TRANCES = 'Can enter martial trances',
--NOSTUCKINS = 'Weapons can not get stuck',
--PUS = 'Has pus',
--ITEMCORPSE = 'Leaves a special corpse',
--GETS_WOUND_INFECTIONS = 'Wounds can become infected',
--NOSMELLYROT = 'Rot does not produce miasma',
--REMAINS_UNDETERMINED = false
--LAIR_HUNTER = 'Hunts adventurers in its lair',
--LIKES_FIGHTING = false
--VERMIN_HATEABLE = false
--MAGICAL = false
--NATURAL = 'Natural',
--BABY = false
--CHILD = false
--MULTIPLE_LITTER_RARE = false
--FEATURE_ATTACK_GROUP = false
--LAYS_EGGS = 'Lays eggs'
--MEGABEAST = false
--SEMIMEGABEAST = false
--ALL_ACTIVE = true
--DIURNAL = false
--NOCTURNAL = false
--CREPUSCULAR = false
--MATUTINAL = false
--VESPERTINE = false
--GETS_INFECTIONS_FROM_ROT = 'Can get infections from necrotic tissue',
--ALCOHOL_DEPENDENT = 'Needs alcohol to function',
--POWER = false
--CASTE_TILE = false
--CASTE_COLOR = false
--FEATURE_BEAST = false
--TITAN = false
--UNIQUE_DEMON = false
--DEMON = false
--MANNERISM_LAUGH = false
--MANNERISM_SMILE = false
--MANNERISM_WALK = false
--MANNERISM_SIT = false
--MANNERISM_BREATH = false
--MANNERISM_POSTURE = false
--MANNERISM_STRETCH = false
--MANNERISM_EYELIDS = false
--NIGHT_CREATURE_ANY = false
--NIGHT_CREATURE_HUNTER = false
--NIGHT_CREATURE_BOGEYMAN = false
--CONVERTED_SPOUSE = false
--SPOUSE_CONVERTER = false
--SPOUSE_CONVERSION_TARGET = false
--DIE_WHEN_VERMIN_BITE = 'Dies after attacking',
--REMAINS_ON_VERMIN_BITE_DEATH = false
--COLONY_EXTERNAL = 'Hovers around its colony',
--LAYS_UNUSUAL_EGGS = 'Lays a special egg',
--RETURNS_VERMIN_KILLS_TO_OWNER = 'Returns vermin to its owner',
--ADOPTS_OWNER = 'Adopts an owner',
--NO_PHYS_ATT_GAIN = 'Can not gain physical skills',
--NO_PHYS_ATT_RUST = 'Can not lose physical skills',
--BLOODSUCKER = 'Will drain blood from victims',
--NO_VEGETATION_PERTURB = false
--DIVE_HUNTS_VERMIN = 'Hunts vermin from the air',
--LOCAL_POPS_CONTROLLABLE = false
--OUTSIDER_CONTROLLABLE = false
--LOCAL_POPS_PRODUCE_HEROES = false
--STRANGE_MOODS = false
             }

function tchelper(first, rest)
  return first:upper()..rest:lower()
end

function center(str, length)
 local string1 = str
 local string2 = string.format("%"..tostring(math.floor((length-#string1)/2)).."s"..string1,"")
 local string3 = string.format(string2.."%"..tostring(math.ceil((length-#string1)/2)).."s","")
 return string3
end

function changeViewScreen(subviews,viewcheck,mode,base)
 for i = 1,viewcheck.baseNum do
  if subviews[viewcheck.base[i]].visible then
   n = i
   break
  end
 end
 
 if mode == 'base' then
  if not base then
   if n ~= viewcheck.baseNum then
    n = n + 1
   else
    n = 1
   end
   base = viewcheck.base[n]
  end
  for _,view in pairs(subviews) do
   view.visible = false
   view.active = false
  end
  subviews[base].active = true
  subviews[base].visible = true
  for _,view in pairs(viewcheck[base][1]) do
   subviews[view].visible = true
   subviews[view].active = true
   if subviews[view].edit then
    subviews[view].edit.visible = true
    subviews[view].edit.active = true
   end
  end
  if viewcheck.always then
   for _,view in ipairs(viewcheck.always) do
    subviews[view].visible = true
   end
  end
 elseif mode == 'up' then
  base = viewcheck.base[n]
  for i = 1, #viewcheck[base] do
   if subviews[viewcheck[base][i][1]].visible then
    if i == 1 then
     return false
    else
     for _,view in pairs(viewcheck[base][i]) do
      subviews[view].visible = false
      subviews[view].active = false
      if subviews[view].edit then
       subviews[view].edit.visible = false
       subviews[view].edit.active = false
      end
     end
     for _,view in pairs(viewcheck[base][i-1]) do
      subviews[view].visible = true
      subviews[view].active = true
      if subviews[view].edit then
       subviews[view].edit.visible = true
       subviews[view].edit.active = true
      end
     end     
    end
    return true
   end
  end 
 elseif mode == 'down' then
  base = viewcheck.base[n]
  for i = 1, #viewcheck[base] do
   if subviews[viewcheck[base][i][1]].visible then
    if i == #viewcheck[base] then
     return false
    else
     for _,view in pairs(viewcheck[base][i]) do
      subviews[view].visible = false
      subviews[view].active = false
      if subviews[view].edit then
       subviews[view].edit.visible = false
       subviews[view].edit.active = false
      end
     end
     for _,view in pairs(viewcheck[base][i+1]) do
      subviews[view].visible = true
      subviews[view].active = true
      if subviews[view].edit then
       subviews[view].edit.visible = true
       subviews[view].edit.active = true
      end
     end     
    end
    return true
   end
  end
 end
end

function makeWidgetList(widget,method,list,options)
 options = options or {}
 color = options.pen or COLOR_WHITE
 w = options.width or 40
 rjustify = options.rjustify or false

 if options.replacement then
  temp_list = {}
  for first,second in pairs(list) do
   temp_first = options.replacement[first] or #temp_list+1
   temp_second = options.replacement[second] or #temp_list+1
   temp_list[temp_first] = temp_second
  end
  list = temp_list
 end
 
 local input = {}
 if method == 'first' then
  for first,_ in pairs(list) do
   table.insert(input,{text=first,pen=color,width=w,rjustify=rjustify})
  end
 elseif method == 'second' then
  for _,second in pairs(list) do
   table.insert(input,{text=second,pen=color,width=w,rjustify=rjustify})
  end
 elseif method == 'center' then
  table.insert(input,{text=center(list,w),width=w,pen=color,rjustify=rjustify})
 end
 widget:setChoices(input)
end

function insertWidgetInput(input,method,list,options)
 options = options or {}
 pen = options.pen or COLOR_WHITE
 width = options.width or 40
 rjustify = options.rjustify or false
 temp_list_length = 0
 
 if options.replacement then
  temp_list = {}
  if method == 'header' then
   for first,second in pairs(list.second) do
    temp_first = options.replacement[first] or #temp_list+1
    temp_second = options.replacement[second] or #temp_list+1
    if tonumber(temp_second) and not tonumber(temp_first) then 
     temp_second = temp_first 
     temp_first = first
    elseif tonumber(temp_first) and not tonumber(temp_second) then
     temp_first = second
    end
    if not tonumber(temp_second) and not tonumber(temp_first) then
     temp_list[temp_first] = temp_second
     temp_list_length = temp_list_length + 1
    end
   end
   list.second = temp_list
   list.length = temp_list_length
  else
   for first,second in pairs(list) do
    temp_first = options.replacement[first] or #temp_list+1
    temp_second = options.replacement[second] or #temp_list+1
    if tonumber(temp_second) and not tonumber(temp_first) then 
     temp_second = temp_first 
     temp_first = first
    elseif tonumber(temp_first) and not tonumber(temp_second) then
     temp_first = second
    end
    if not tonumber(temp_second) and not tonumber(temp_first) then
     temp_list[temp_first] = temp_second
     temp_list_length = temp_list_length + 1
    end
   end
   list = temp_list
  end
 else
  list.length = 0
  if type(list.second) == 'table' then
   for _,_ in pairs(list.second) do
    list.length = list.length + 1
   end
  end
 end
 
 if method == 'first' then
  for first,_ in pairs(list) do
   table.insert(input,{text=first,pen=pen,width=width,rjustify=rjustify})
  end
 elseif method == 'second' then
  for _,second in pairs(list) do
   table.insert(input,{text=second,pen=pen,width=width,rjustify=rjustify})
  end
 elseif method == 'center' then
  table.insert(input,{text=center(list,width),width=width,pen=pen,rjustify=rjustify})
 elseif method == 'header' then
  if type(list.second) == 'table' then
   local check = true
   if list.length == 0 then
    table.insert(input,{text={{text=list.header,width=#list.header,pen=pen},{text='--',rjustify=true,width=width-#list.header,pen=pen}}})
   else
    for first,second in pairs(list.second) do
     if options.fill == 'flags' then
      fill = first
     elseif options.fill == 'both' then
      fill = second..' ['..first..']'
     else
      fill = second
     end
     if check then
      table.insert(input,{text={{text=list.header,width=#list.header,pen=pen},{text=fill,rjustify=true,width=width-#list.header,pen=pen}}})
      check = false
     else
      table.insert(input,{text={{text='',width=#list.header,pen=pen},{text=fill,rjustify=true,width=width-#list.header,pen=pen}}})
     end
    end
   end
  else
   table.insert(input,{text={{text=list.header,width=#list.header,pen=pen},{text=list.second,rjustify=true,width=width-#list.header,pen=pen}}})
  end
 end
 return input
end

-- For CompendiumUi
function getSortBiome(biomeTokens,list,frame) -- Sorts creatures and plants by their biome
 local utils = require 'utils'
 local split = utils.split_string
 local biomes = {}
 if frame == 'Bestiary' then
  for _,x in pairs(list) do
   for flag,check in pairs(x.flags) do
    if check then
     if split(flag,'_')[1] == 'BIOME' then
      biomes[biomeTokens[flag]] = biomes[biomeTokens[flag]] or {}
      biomes[biomeTokens[flag]][#biomes[biomeTokens[flag]]+1] = x.name[0]
     end
    end
   end
  end
 elseif frame == 'Herbiary' then
  for _,x in pairs(list) do
   for flag,check in pairs(x.flags) do
    if check then
     if split(flag,'_')[1] == 'BIOME' then
      biomes[biomeTokens[flag]] = biomes[biomeTokens[flag]] or {}
      biomes[biomeTokens[flag]][#biomes[biomeTokens[flag]]+1] = x.name
     end
    end
   end
  end 
 end
 return biomes
end

function getSortType(list,frame)
 local types = {}
 if frame == 'Bestiary' then
  for _,x in pairs(list) do
   for flag,check in pairs(x.flags) do
    if check then
     if typeCreatureFlags[flag] then
      types[flag] = types[flag] or {}
      types[flag][#types[flag]+1] = x.name[0]
     end
    end
   end
  end
 end
 return types
end

function getShow(choice,frame) -- Gets the list of objects (creature, plant, item, material, etc...)
 if frame == 'Bestiary' then
  return getShowBestiary(choice)
 elseif frame == 'Herbiary' then
  return getShowHerbiary(choice)
 elseif frame == 'Items' then
  return getShowItems(choice)
 elseif frame == 'Inorganics' then
  return getShowInorganic(choice)
 end
end

function getShowBestiary(choice)
 local creatureList = df.global.world.raws.creatures.alphabetic
 local creatures = {}
 local creatureNames = {}
 for _,creature in pairs(creatureList) do
  if choice.text == 'All Creatures' then
   creatures[#creatures+1] = creature
   creatureNames[#creatureNames+1] = creature.name[0]
  elseif choice.text == 'GOOD Creatures' then
   if creature.flags.GOOD then
    creatures[#creatures+1] = creature
    creatureNames[#creatureNames+1] = creature.name[0]
   end
  elseif choice.text == 'EVIL Creatures' then
   if creature.flags.EVIL then
    creatures[#creatures+1] = creature
    creatureNames[#creatureNames+1] = creature.name[0]
   end
  elseif choice.text == 'SAVAGE Creatures' then
   if creature.flags.SAVAGE then
    creatures[#creatures+1] = creature
    creatureNames[#creatureNames+1] = creature.name[0]
   end
  end
 end
 return creatures,creatureNames
end

function getShowHerbiary(choice)
 local plants = {}
 local plantNames = {}
 if choice.text == 'All Plants' then
  array = df.global.world.raws.plants.all
 elseif choice.text == 'Trees' then
  array = df.global.world.raws.plants.trees
 elseif choice.text == 'Bushes' then
  array = df.global.world.raws.plants.bushes
 elseif choice.text == 'Grasses' then
  array = df.global.world.raws.plants.grasses
 end
 for _,plant in pairs(array) do
  plants[#plants+1] = plant
  plantNames[#plantNames+1] = plant.name
 end
 return plants,plantNames
end

function getShowItems(choice)
 local items = {}
 local itemNames = {}
 if choice.text == 'All Items' then
  array = df.global.world.raws.itemdefs.all
 elseif choice.text == 'Weapons' then
  array = df.global.world.raws.itemdefs.weapons
 elseif choice.text == 'Helms' then
  array = df.global.world.raws.itemdefs.helms
 elseif choice.text == 'Armor' then
  array = df.global.world.raws.itemdefs.armor
 elseif choice.text == 'Gloves' then
  array = df.global.world.raws.itemdefs.gloves
 elseif choice.text == 'Pants' then
  array = df.global.world.raws.itemdefs.pants
 elseif choice.text == 'Shoes' then
  array = df.global.world.raws.itemdefs.shoes
 elseif choice.text == 'Shields' then
  array = df.global.world.raws.itemdefs.shields
 elseif choice.text == 'Ammo' then
  array = df.global.world.raws.itemdefs.ammo
 elseif choice.text == 'Siege Ammo' then
  array = df.global.world.raws.itemdefs.siege_ammo
 elseif choice.text == 'Trap Components' then
  array = df.global.world.raws.itemdefs.trapcomps
 elseif choice.text == 'Toys' then
  array = df.global.world.raws.itemdefs.toys
 elseif choice.text == 'Tools' then
  array = df.global.world.raws.itemdefs.tools
 elseif choice.text == 'Instruments' then
  array = df.global.world.raws.itemdefs.instruments
 elseif choice.text == 'Food' then
  array = df.global.world.raws.itemdefs.food
 end
 for _,item in pairs(array) do
  items[#items+1] = item
  itemNames[#itemNames+1] = item.name
 end
 return items,itemNames
end

function getShowInorganic(choice)
 local inorganics = {}
 local inorganicNames = {}
 local array = df.global.world.raws.inorganics
 for _,inorganic in pairs(array) do
  if choice.text == 'All Inorganics' then
   inorganics[#inorganics+1] = inorganic
   inorganicNames[#inorganicNames+1] = inorganic.material.state_name.Solid
  elseif choice.text == 'Metals' then
   if inorganic.material.flags.IS_METAL then
    inorganics[#inorganics+1] = inorganic
    inorganicNames[#inorganicNames+1] = inorganic.material.state_name.Solid    
   end
  elseif choice.text == 'Stone' then
   if inorganic.material.flags.IS_STONE then
    inorganics[#inorganics+1] = inorganic
    inorganicNames[#inorganicNames+1] = inorganic.material.state_name.Solid    
   end   
  elseif choice.text == 'Gems' then
   if inorganic.material.flags.IS_GEM then
    inorganics[#inorganics+1] = inorganic
    inorganicNames[#inorganicNames+1] = inorganic.material.state_name.Solid    
   end   
  elseif choice.text == 'Glass' then
   if inorganic.material.flags.IS_GLASS then
    inorganics[#inorganics+1] = inorganic
    inorganicNames[#inorganicNames+1] = inorganic.material.state_name.Solid    
   end   
  end
 end
 return inorganics,inorganicNames
end

function getEntry(name,frame) -- Gets sub-objects of an object (castes for a creature, products for a plant, etc...)
 if frame == 'Bestiary' then
  return getEntryBestiary(name)
 elseif frame == 'Herbiary' then
  return getEntryHerbiary(name)
 elseif frame == 'Items' then
  return getEntryItems(name)
 elseif frame == 'Inorganics' then
 end
end

function getEntryBestiary(name)
 local creature = nil
 local castes = {}
 local creatureList = df.global.world.raws.creatures.alphabetic
 for _,x in pairs(creatureList) do
  if x.name[0] == name then
   creature = x
   break
  end
 end
 if not creature then 
  return nil, nil
 end
 for _,caste in pairs(creature.caste) do
  if caste.gender == 0 then
   castes[#castes+1] = caste.caste_name[0]..' (F)'
  elseif caste.gender == 1 then
   castes[#castes+1] = caste.caste_name[0]..' (M)'
  else
   castes[#castes+1] = caste.caste_name[0]..' (N)'
  end
 end
 return creature, castes
end

function getEntryHerbiary(name)
 local plant = nil
 local products = {}
 local plantList = df.global.world.raws.plants.all
 for _,x in pairs(plantList) do
  if x.name == name then
   plant = x
   break
  end
 end
 if not plant then 
  return nil, nil
 end
 for _,material in pairs(plant.material) do
  if material.flags.LIQUID_MISC or material.flags.ALCOHOL then
   mat_name = material.state_name.Liquid
  else
   mat_name = material.state_name.Solid
  end
  a = string.gsub(mat_name,'%p','')
  b = string.gsub(name,'%p','')
  if string.find(a,b) then
   product = mat_name
  else
   product = name..' '..mat_name
  end
  products[#products+1] = product
 end
 return plant, products
end

function getEntryItems(name)
 local item = nil
 local item2 = {}
 local itemList = df.global.world.raws.itemdefs.all
 for _,x in pairs(itemList) do
  if x.name == name then
   item = x
   break
  end
 end
 if not item then
  return nil,nil
 end
 return item,item2
end

function getDetails(frame,entry,index)
 if frame == 'Bestiary' then
  if index then
   return getCreatureCasteDetails(entry,index)
  else
   return getCreatureDetails(entry)
  end
 elseif frame == 'Herbiary' then
  if index then
   return getPlantProductDetails(entry,index)
  else
   return getPlantDetails(entry)
  end
 elseif frame == 'Items' then
  
 end
end

function getCreatureDetails(creature)
 return
end

function getCreatureCasteDetails(creature,caste) -- Gets all the details of a creature/caste combination
 local utils = require 'utils'
 local split = utils.split_string
 local input = {}
 local input2 = {}
 local header = {}
 local creature = creature
 local caste = creature.caste[caste]
 local info = {}
 info.attacks = {}
 info.flags = {}
 info.interactions = {}
 info.biomes = {}
 info.products = {}
 info.butcher_corpse = {}
 info.extra_butcher = {}
 info.description = ''
 info.item_corpse = dfhack.script_environment('functions/unit').getItemCorpse(caste)
 if info.item_corpse == 'Corpse' then
  info.butcher_corpse[#info.butcher_corpse+1] = 'Butcher Products'
  info.butcher_corpse[#info.butcher_corpse+1] = 'will go here'
 else
  info.butcher_corpse[#info.butcher_corpse+1] = 'NA'
 end
 info.extra_butcher[1] = 'Extra Butcher Objects'
 info.extra_butcher[2] = 'will go here'
 if caste.extracts.milkable_mat >= 0 then
  matinfo = dfhack.matinfo.decode(caste.extracts.milkable_mat,caste.extracts.milkable_matidx)
  c = matinfo.creature.name[0]
  m = matinfo.material.state_name.Solid
  info.products[#info.products+1] = c..' '..m
 end
 if caste.extracts.webber_mat >= 0 then
  matinfo = dfhack.matinfo.decode(caste.extracts.webber_mat,caste.extracts.webber_matidx)
  c = matinfo.creature.name[0]
  m = matinfo.material.state_name.Solid
  info.products[#info.products+1] = c..' '..m
 end
 for i,matid in ipairs(caste.extracts.extract_mat) do
  matinfo = dfhack.matinfo.decode(matid,caste.extracts.extract_matidx[i])
  c = matinfo.creature.name[0]
  m = matinfo.material.state_name.Liquid
  info.products[#info.products+1] = c..' '..m
 end
 for _,attack in pairs(caste.body_info.attacks) do
  if attack.specialattack_mat_type then
   matinfo = dfhack.matinfo.decode(attack.specialattack_mat_type[0],attack.specialattack_mat_index[0])
   m = matinfo.material.state_name.Liquid
   info.products[#info.products+1] = m
  end
 end
 info.adultsize = caste.misc.adult_size/100
 info.maxage = (caste.misc.maxage_min + caste.misc.maxage_max)/2
 if info.maxage <= 0 then info.maxage = 'NA' end
 
 local n = math.floor(#caste.description/85)+1
 for i = 1,n do
  info.description = info.description..string.sub(caste.description,1+85*(i-1),85*i)..'\n'
 end
 for _,attack in pairs(caste.body_info.attacks) do
  info.attacks[attack.name] = attack.verb_2nd
 end
 for _,interaction in pairs(caste.body_info.interactions) do
  info.interactions[#info.interactions+1] = interaction.unk.adv_name
 end
 for flag,check in pairs(creature.flags) do
  if check then
   info.flags[#info.flags+1] = flag
  end
 end
 for flag,check in pairs(caste.flags) do
  if check then
   info.flags[#info.flags+1] = flag
  end
 end
 for _,line in pairs(creature.raws) do
  if split(line.value,':')[1] == '[BIOME' then
   info.biomes[#info.biomes+1] = split(split(line.value,':')[2],']')[1]
  end
 end
 if #info.biomes == 0 then info.biomes = info.flags end
 
 table.insert(header,{text={{text=center('Description',85),width=85,pen=COLOR_YELLOW}}})
 for _,second in pairs(split(info.description,'\n')) do
  table.insert(header,{text={{text=second,pen=COLOR_WHITE,width=85}}})
 end

 table.insert(input,{text={{text=center('Details',40),width=40,pen=COLOR_YELLOW}}})
 input = insertWidgetInput(input,'header',{header='Creature Name:',second=creature.name[0]},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Caste Name:',second=caste.caste_name[0]},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Average Life:',second=tostring(info.maxage)..' years'},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Adult Size:',second=tostring(info.adultsize)..' kg'},{pen=COLOR_LIGHTGREEN})
 table.insert(input,{text={{text=center('Environment ',40),width=40,pen=COLOR_YELLOW}}})
 input = insertWidgetInput(input,'header',{header='Biomes:',second=info.biomes},{replacement=biomeTokens,pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Habitat:',second=info.flags},{replacement=habitatFlags,pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Seasons:',second=info.flags},{replacement=seasonFlags,pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Active Times:',second=info.flags},{replacement=activeFlags,pen=COLOR_LIGHTGREEN})
 table.insert(input,{text={{text=center('Attacks and Interactions',40),width=40,pen=COLOR_YELLOW}}})
 input = insertWidgetInput(input,'header',{header='Attacks:',second=info.attacks},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Interactions:',second=info.interactions},{pen=COLOR_LIGHTGREEN})
 
 table.insert(input2,{text={{text=center('Flags',40),width=40,pen=COLOR_YELLOW}}})
 input2 = insertWidgetInput(input2,'header',{header='Utility Flags:',second=info.flags},{replacement=utilityFlags,fill='flags',pen=COLOR_LIGHTGREEN})
 input2 = insertWidgetInput(input2,'header',{header='Behavior Flags:',second=info.flags},{replacement=behaviorFlags,fill='flags',pen=COLOR_LIGHTCYAN})
 input2 = insertWidgetInput(input2,'header',{header='Diet Flags:',second=info.flags},{replacement=dietFlags,fill='flags',pen=COLOR_LIGHTGREEN})
 input2 = insertWidgetInput(input2,'header',{header='Movement Flags:',second=info.flags},{replacement=movementFlags,fill='flags',pen=COLOR_LIGHTCYAN})
 table.insert(input2,{text={{text=center('Corpse, Products, and Extracts',40),width=40,pen=COLOR_YELLOW}}})
 table.insert(input2,{text={{text='Corpse:',width=10,pen=COLOR_LIGHTGREEN},{text=info.item_corpse,rjustify=true,width=30,pen=COLOR_LIGHTGREEN}}})
 input2 = insertWidgetInput(input2,'header',{header='Butcher Parts:',second=info.butcher_corpse},{pen=COLOR_LIGHTCYAN})
 input2 = insertWidgetInput(input2,'header',{header='Extra Butcher:',second=info.extra_butcher},{pen=COLOR_LIGHTGREEN})
 input2 = insertWidgetInput(input2,'header',{header='Extracts:',second=info.products},{pen=COLOR_LIGHTCYAN})
 
 return header,input,input2
end

function getPlantDetails(plant) -- Gets all the details of a plant/product combination
 local input = {}
 local input2 = {}
 local header = {}
 local info = {}
 info.flags = {}
 info.growths = {}
 info.description = 'Plant Description Will Go Here'
 info.growdur = plant.growdur
 info.value = plant.value
 info.frequency = plant.frequency
 info.clustersize = plant.clustersize
 info.products = {}
 for flag,check in pairs(plant.flags) do
  if check then
   info.flags[#info.flags+1] = flag
  end
 end
 for _,growth in pairs(plant.growths) do
  info.growths[#info.growths+1] = growth.name
 end
 if plant.material_defs.type_basic_mat >= 0 then info.structure = 'Structural Mat' end
 if plant.material_defs.type_tree >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_tree,plant.material_defs.idx_tree).material.state_name.Solid end
 if plant.material_defs.type_drink >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_drink,plant.material_defs.idx_drink).material.state_name.Liquid end
 if plant.material_defs.type_thread >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_thread,plant.material_defs.idx_thread).material.state_name.Solid end
 if plant.material_defs.type_mill >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_mill,plant.material_defs.idx_mill).material.state_name.Solid end
 if plant.material_defs.type_extract_vial >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_extract_vial,plant.material_defs.idx_extract_vial).material.state_name.Solid end
 if plant.material_defs.type_extract_barrel >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_extract_barrel,plant.material_defs.idx_extract_barrel).material.state_name.Solid end
 if plant.material_defs.type_extract_still_vial >= 0 then info.products[#info.products+1] = dfhack.matinfo.decode(plant.material_defs.type_extract_still_vial,plant.material_defs.idx_extract_still_vial).material.state_name.Solid end
  
 table.insert(header,{text={{text=center('Description',85),pen=COLOR_YELLOW,width=85}}})
 table.insert(header,{text={{text=info.description,pen=COLOR_WHITE,width=85}}})
  
 table.insert(input,{text={{text=center('Details',40),pen=COLOR_YELLOW,width=40}}})
 input = insertWidgetInput(input,'header',{header='Plant Name:',second=plant.name},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Value:',second=plant.value},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Frequency:',second=plant.frequency},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Cluster Size:',second=plant.clustersize},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Grow Duration:',second=plant.growdur},{pen=COLOR_LIGHTCYAN})
 table.insert(input,{text={{text=center('Environment',40),pen=COLOR_YELLOW,width=40}}})
 input = insertWidgetInput(input,'header',{header='Biomes:',second=info.flags},{replacement=biomeTokens,pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Seasons:',second=info.flags},{replacement=seasonPlantFlags,pen=COLOR_LIGHTCYAN})
  
 table.insert(input2,{text={{text=center('Products and Growths',40),pen=COLOR_YELLOW,width=40}}})
 input2 = insertWidgetInput(input2,'header',{header='Products:',second=info.products},{pen=COLOR_LIGHTGREEN})
 input2 = insertWidgetInput(input2,'header',{header='Growths:',second=info.growths},{pen=COLOR_LIGHTCYAN})
 return header, input, input2
end

function getPlantProductDetails(plant,productID)
 local utils = require 'utils'
 local split = utils.split_string
 local product = plant.material[productID]
 local header = {}
 local input = {}
 local input2 = {}
 local info = {}
 info.syndromes = {}
 info.edible = {}
 info.flags = {}
 info.yields = {}
 info.fracture = {}
 info.strain = {}
 for _,syndrome in pairs(product.syndrome) do
  info.syndromes[#info.syndromes+1] = syndrome.syn_name
 end
 for flag,check in pairs(product.flags) do
  if check then
   info.flags[#info.flags+1] = flag
  end
 end
 for flag,check in pairs(product.flags) do
  if check then
   if split(flag,'_')[1] == 'EDIBLE' then
    info.edible[#info.edible+1] = string.lower(split(flag,'_')[2])
   end
  end
 end
 for flag,val in pairs(product.strength.yield) do
  info.yields[#info.yields+1] = string.lower(flag)..' '..val
 end
 for flag,val in pairs(product.strength.fracture) do
  info.fracture[#info.fracture+1] = string.lower(flag)..' '..val
 end
 for flag,val in pairs(product.strength.strain_at_yield) do
  info.strain[#info.strain+1] = string.lower(flag)..' '..val
 end
 table.insert(input,{text={{text=center('Numbers',40),pen=COLOR_YELLOW,width=40}}})
 input = insertWidgetInput(input,'header',{header='Material Value:',second=product.material_value},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Extract Storage:',second=product.extract_storage},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Absorption:',second=product.strength.absorption},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Max Edge:',second=product.strength.max_edge},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Yields:',second=info.yields},{pen=COLOR_LIGHTCYAN})
 input = insertWidgetInput(input,'header',{header='Fracture:',second=info.fracture},{pen=COLOR_LIGHTGREEN})
 input = insertWidgetInput(input,'header',{header='Strains:',second=info.strain},{pen=COLOR_LIGHTCYAN})
 
 table.insert(input2,{text={{text=center('Uses',40),pen=COLOR_YELLOW,width=40}}})
 input2 = insertWidgetInput(input2,'header',{header='Edible:',second=info.flags},{replacement=materialEdibleFlags,pen=COLOR_LIGHTCYAN})
 input2 = insertWidgetInput(input2,'header',{header='Items:',second=info.flags},{replacement=materialItemFlags,pen=COLOR_LIGHTGREEN})
 table.insert(input2,{text={{text=center('Syndromes',40),pen=COLOR_YELLOW,width=40}}})
 input2 = insertWidgetInput(input2,'header',{header='Syndromes:',second=info.syndromes},{pen=COLOR_LIGHTCYAN})
 
 return header, input, input2
end

-- For UnitViewUi
function getUnitName(unit,translate)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 name = dfhack.units.getVisibleName(unit)
 name = dfhack.TranslateName(name,translate)
 return name,nickname
end

function getCasteName(unit)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 race = df.global.world.raws.creatures.all[tonumber(unit.race)].name[0]
 if unit.sex == 1 then 
  sex = 'Male '
 elseif unit.sex == 0 then 
  sex = 'Female ' 
 else
  sex = ''
 end
 caste = df.global.world.raws.creatures.all[tonumber(unit.race)].caste[tonumber(unit.caste)].caste_name[0]
 name = race:gsub("^%l", string.upper)..', '..sex..caste:gsub("(%a)([%w_']*)", tchelper)
 return name
end

function getSyndromes(unit)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 syn = {}
 syn_detail = {}
 for i,x in pairs(unit.syndromes.active) do
  curticks = x.ticks
  endticks = -1
  for j,y in pairs(df.global.world.raws.syndromes.all[tonumber(x.type)].ce) do
   if y['end'] > endticks then endticks = y['end'] end
  end
  if endticks == -1 then
   duration = 'Permenant'
  else
   duration = tostring(endticks-curticks)
  end
  syn[i+1] = {df.global.world.raws.syndromes.all[tonumber(x.type)].syn_name:gsub("(%a)([%w_']*)", tchelper),duration,curticks}
  if syn[i+1][1] == '' then
   syn[i+1][1] = 'Unknown'
  end
  syn_detail[i+1] = df.global.world.raws.syndromes.all[tonumber(x.type)].ce
 end
 if #syn == 0 then
  syn[1] = {'None','',''}
  syn_detail[1] = {}
 end
 return syn, syn_detail
end

function getInteractions(unit)
 local utils = require 'utils'
 local split = utils.split_string
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 ints = {}
 t_ints = {}
 for i,x in pairs(df.global.world.raws.creatures.all[tonumber(unit.race)].caste[tonumber(unit.caste)].body_info.interactions) do
  s = -1
  check = false
  name = false
  for j,y in pairs(df.global.world.raws.creatures.all[tonumber(unit.race)].raws) do
   if split(y.value,':')[1] == '[CAN_DO_INTERACTION' then
    s = s + 1
    if s == i then
     check = true
    elseif s > i then
     break
    end
   end
   if check then
    if split(y.value,':')[2] == 'ADV_NAME' then
     ints[i+1] = split(split(y.value,':')[3],']')[1]
     name = true
	end
   end
  end
  if not name then
   ints[i+1] = 'Unknown'
  end
 end
 if #ints == 0 then
  ints[1] = 'None'
 end
 s = 0
 for i,x in pairs(unit.syndromes.active) do
  for j,y in pairs(df.global.world.raws.syndromes.all[tonumber(x.type)].ce) do
   if y._type == df['creature_interaction_effect_can_do_interactionst'] then
    t_ints[s+1] = y.name
	s = s + 1
   end
  end
 end 
 if #t_ints == 0 then
  t_ints[1] = 'None'
 end
 return ints, t_ints
end

function getAttributes(unit)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 p_atts = {}
 m_atts = {}
 local persistTable = require 'persist-table'
 if persistTable.GlobalTable.roses then
  for i,x in pairs(unit.body.physical_attrs) do
   local total,base,change,class,item,syndrome = dfhack.script_environment('functions/unit').trackAttribute(unit,i,nil,nil,nil,nil,'get')
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)] = {}
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Base'] = base
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Current'] = total
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Class'] = class
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Item'] = item
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Syndrome'] = syndrome
  end
  for i,x in pairs(unit.status.current_soul.mental_attrs) do
   local total,base,change,class,item,syndrome = dfhack.script_environment('functions/unit').trackAttribute(unit,i,nil,nil,nil,nil,'get')
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)] = {}
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Base'] = base
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Current'] = total
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Class'] = class
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Item'] = item
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Syndrome'] = syndrome
  end
 else
  for i,x in pairs(unit.body.physical_attrs) do
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)] = {}
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Base'] = dfhack.units.getPhysicalAttrValue(unit,df.physical_attribute_type[i])
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Current'] = dfhack.units.getPhysicalAttrValue(unit,df.physical_attribute_type[i])
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Class'] = 0
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Item'] = 0
   p_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Syndrome'] = 0
  end
  for i,x in pairs(unit.status.current_soul.mental_attrs) do
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)] = {}
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Base'] = dfhack.units.getMentalAttrValue(unit,df.mental_attribute_type[i])
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Current'] = dfhack.units.getMentalAttrValue(unit,df.mental_attribute_type[i])
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Class'] = 0
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Item'] = 0
   m_atts[i:gsub("%_"," "):gsub("(%a)([%w_']*)", tchelper)]['Syndrome'] = 0
  end
 end
 return p_atts, m_atts
end

function getSkills(unit)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 skl = {}
 for i,x in pairs(unit.status.current_soul.skills) do
  skl[df.job_skill.attrs[x.id].caption_noun] = {df.skill_rating[dfhack.units.getEffectiveSkill(unit,x.id)],dfhack.units.getExperience(unit,x.id),df.job_skill[x.id]}
 end
 return skl
end

function getEntity(unit,translate)
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 ent = ''
 civ = ''
 mem = ''
 if unit.civ_id >= 0 then
  ent = df.global.world.entities.all[unit.civ_id].name
  ent = dfhack.TranslateName(ent,translate)
 end
 if unit.population_id >= 0 then
  civ = df.global.world.entity_populations[unit.population_id].name
  civ = dfhack.TranslateName(civ,translate)
 end
 if unit.hist_figure_id >= 0 then
  hf = df.global.world.history.figures[unit.hist_figure_id]
  for _,link in pairs(hf.entity_links) do
   if link.entity_id ~= unit.civ_id then
    mem = df.global.world.entities.all[link.entity_id].name
    mem = dfhack.TranslateName(mem,translate)
   end
  end
 end
 return ent, civ, mem
end

function getInfo(tar)
 local gui = require 'gui'
 local utils = require 'utils'
 local split = utils.split_string
 if tonumber(unit) then
  unit = df.unit.find(tonumber(unit))
 end
 
 game_mode = df.global.gamemode
 if game_mode == 0 then
  local temp_screen = df.viewscreen_unitst:new()
  temp_screen.unit = tar
  gui.simulateInput(temp_screen,1)
 elseif game_mode == 1 then
  local temp_screen = df.viewscreen_dungeon_monsterstatusst:new()
  temp_screen.unit = tar
  gui.simulateInput(temp_screen,291)
 end
 local read_screen = dfhack.gui.getCurViewscreen()
 local info = ''
 local info_pars = {}
 local no_color = {}
 local colors = {}
 local information = {}
 information.quote = ''
 information.age = ''
 information.wounds = ''
 information.preferences = ''
 information.attributes = {'',''}
 local a_num = 1
 information.worship = ''
 information.membership = ''
 information.values = ''
 information.thoughts = ''
 information.description = ''
 information.appearance = ''
 information.traits = ''
 local check = 0
 for i,x in pairs(read_screen.src_text) do
  info = info..' '..x.value
 end
 dfhack.screen.dismiss(read_screen)
 local info_temp = split(info,'%[B%]')
 i = 0
 for k,v in pairs(info_temp) do
  temp = split(v,'%[P%]')
  for l,w in pairs(temp) do
   info_pars[i] = w
   i = i + 1
  end
 end
 for k,v in ipairs(info_pars) do
  no_color[k] = string.gsub(v,"%[C:.:.:.%]","")
  colors[k] = string.sub(v,1,9)
  if string.find(string.sub(v,1,18),"%[C:.:.:.%]",9) then
   colors[k] = string.sub(v,10,18)
  end
 end
 for k,vv in ipairs(no_color) do
  v = info_pars[k]
  if string.find(vv,'"') == 1 then
   information.quote = string.gsub(v,'%[C:.:.:.%]','')
  elseif colors[k] == '[C:3:0:1]' then
   information.worship = string.gsub(v,'%[C:.:.:.%]','')
   check = 1
  elseif colors[k] == '[C:1:0:1]' then
   information.membership = string.gsub(v,'%[C:.:.:.%]','')
   check = 1
  elseif colors[k] == '[C:6:0:1]' then
   information.age = string.gsub(v,'%[C:.:.:.%]','')
   check = 1
  elseif colors[k] == '[C:2:0:0]' or colors[k] == '[C:4:0:0]' then
   information.attributes[a_num] = string.gsub(v,'%[C:.:.:.%]','')
   a_num = a_num + 1
   check = 2
  elseif colors[k] == '[C:2:0:1]' then
   information.preferences = string.gsub(v,'%[C:.:.:.%]','')
   check = 2
  elseif colors[k] == '[C:4:0:1]' then
   information.wounds = string.gsub(v,'%[C:.:.:.%]','')
   check = 1
  elseif (colors[k] == '[C:7:0:0]' or colors[k] == '[C:7:0:1]') and check == 0 then
   information.thoughts = string.gsub(v,'%[C:.:.:.%]','')
   check = 1
  elseif (colors[k] == '[C:7:0:0]' or colors[k] == '[C:7:0:1]') and check == 1 then
   information.appearance = string.gsub(v,'%[C:.:.:.%]','')
   check = 2
  elseif (colors[k] == '[C:7:0:0]' or colors[k] == '[C:7:0:1]') and check == 2 then
   information.values = string.gsub(v,'%[C:.:.:.%]','')
   check = 3
  elseif (colors[k] == '[C:7:0:0]' or colors[k] == '[C:7:0:1]') and check == 3 then
   information.traits = string.gsub(v,'%[C:.:.:.%]','')
   check = 4
  end
 end
 information.description = no_color[#no_color]
 return information
end